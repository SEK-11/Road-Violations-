#!/usr/bin/env python3
"""
Violation Detection Modules
Author: Manus AI
Date: July 15, 2025

This module contains all the specific violation detection algorithms.
"""

import cv2
import numpy as np
import time
import os
import math
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
import logging
from pathlib import Path
from collections import defaultdict, deque

from traffic_violation_detector import DetectionResult, ViolationEvent, ZoneManager
from shapely.geometry import Point
from lane_aware_wrong_side import LaneAwareWrongSideDetector

logger = logging.getLogger(__name__)

class BaseViolationDetector:
    """Base class for all violation detectors"""
    
    def __init__(self, name: str):
        self.name = name
        self.enabled = True
        self.violation_count = 0
        
    def detect(self, detections: List[DetectionResult], frame: np.ndarray, 
               tracker_data: Dict, zones: ZoneManager) -> List[ViolationEvent]:
        """Override this method in subclasses"""
        raise NotImplementedError

class RedLightViolationDetector(BaseViolationDetector):
    """Detects red light and stop line violations"""
    
    def __init__(self):
        super().__init__("Red Light Violation")
        self.traffic_light_state = "unknown"
        self.state_change_time = time.time()
        self.vehicles_in_intersection = set()
        self.processed_violations = set()  # Track IDs of vehicles already processed
        
    def detect(self, detections: List[DetectionResult], frame: np.ndarray, 
               tracker_data: Dict, zones: ZoneManager) -> List[ViolationEvent]:
        violations = []
        
        # Get stop line zones
        stop_line_zones = zones.get_zones_by_type("stop_line")
        
        # Only continue if stop line zones are defined
        if not stop_line_zones:
            return violations
        
        # Find traffic lights in the frame
        traffic_lights = [d for d in detections if d.class_name == 'traffic light']
        
        # Only process if traffic lights are detected
        if traffic_lights:
            # Update traffic light state based on detected traffic lights
            self._update_traffic_light_state(traffic_lights, frame)
        else:
            # No traffic lights detected, set state to unknown
            if self.traffic_light_state != "unknown":
                self.traffic_light_state = "unknown"
                logger.info("No traffic light detected, setting state to unknown")
        
        # Draw traffic light state on frame
        self._draw_traffic_light_state(frame)
        
        # Only detect violations if traffic lights are present and red
        if traffic_lights and self.traffic_light_state == "red":
            for detection in detections:
                if detection.class_name in ['car', 'motorcycle', 'bus', 'truck'] and detection.track_id:
                    # Check if vehicle crosses stop line after red light
                    if self._check_stop_line_violation(detection, tracker_data, stop_line_zones):
                        # Skip if we've already processed this vehicle
                        if detection.track_id in self.processed_violations:
                            continue
                            
                        # Create violation event
                        violation = ViolationEvent(
                            violation_type="red_light_violation",
                            timestamp=datetime.now(),
                            track_id=detection.track_id,
                            location=(detection.bbox[0], detection.bbox[1]),
                            confidence=0.9,
                            evidence={
                                "traffic_light_state": self.traffic_light_state,
                                "bbox": detection.bbox,
                                "vehicle_type": detection.class_name
                            },
                            description=f"{detection.class_name} crossed stop line during red light"
                        )
                        violations.append(violation)
                        self.violation_count += 1
                        
                        # Mark as processed
                        self.processed_violations.add(detection.track_id)
                        
                        logger.warning(f"Red light violation detected: Track {detection.track_id}")
        else:
            # If light is not red, allow reprocessing of vehicles
            self.processed_violations.clear()
        
        return violations
        
    # Image saving method removed - now handled by the main application
    
    def _draw_traffic_light_state(self, frame: np.ndarray):
        """Draw the current traffic light state on the frame"""
        # Define colors for different states
        colors = {
            "red": (0, 0, 255),
            "yellow": (0, 255, 255),
            "green": (0, 255, 0),
            "unknown": (128, 128, 128)
        }
        
        color = colors.get(self.traffic_light_state, colors["unknown"])
        
        # Draw a traffic light indicator in the top-right corner
        height, width = frame.shape[:2]
        indicator_size = 30
        margin = 10
        
        # Draw background
        cv2.rectangle(frame, 
                     (width - indicator_size - margin - 150, margin), 
                     (width - margin, margin + indicator_size + 40), 
                     (0, 0, 0), -1)
        
        # Draw circle for current state
        cv2.circle(frame, 
                  (width - indicator_size//2 - margin - 50, margin + indicator_size//2), 
                  indicator_size//2, color, -1)
        
        # Add text with more information
        if self.traffic_light_state == "unknown":
            status_text = "No Traffic Light Detected"
        else:
            status_text = f"Light: {self.traffic_light_state.upper()}"
            
        cv2.putText(frame, status_text, 
                   (width - indicator_size - margin - 145, margin + indicator_size + 25), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
    
    def _update_traffic_light_state(self, traffic_lights: List[DetectionResult], frame: np.ndarray):
        """Update traffic light state based on detected traffic lights"""
        for detection in traffic_lights:
            # Extract traffic light region
            x1, y1, x2, y2 = detection.bbox
            light_roi = frame[y1:y2, x1:x2]
            
            if light_roi.size > 0:
                # Analyze colors to determine state
                state = self._analyze_traffic_light_colors(light_roi)
                
                # Draw bounding box around traffic light with color indicating state
                color = (0, 0, 255) if state == "red" else (0, 255, 255) if state == "yellow" else (0, 255, 0) if state == "green" else (255, 255, 255)
                cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                cv2.putText(frame, f"Traffic Light: {state.upper()}", (x1, y1 - 10),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
                
                # Update state if it changed
                if state != self.traffic_light_state:
                    self.traffic_light_state = state
                    self.state_change_time = time.time()
                    logger.info(f"Traffic light state changed to: {state}")
                break
    
    def _detect_traffic_lights_by_color(self, frame: np.ndarray):
        """Try to detect traffic lights by color analysis when YOLO doesn't detect them"""
        # Disable this feature - we should only detect traffic lights through YOLO
        # If no traffic light is detected, set state to unknown
        if self.traffic_light_state != "unknown":
            self.traffic_light_state = "unknown"
            logger.info("No traffic light detected, setting state to unknown")
        return
    
    def _analyze_traffic_light_colors(self, light_roi: np.ndarray) -> str:
        """Analyze traffic light colors to determine state with improved accuracy"""
        if light_roi.size == 0:
            return "unknown"
            
        # Method 1: HSV color analysis (original)
        hsv = cv2.cvtColor(light_roi, cv2.COLOR_BGR2HSV)
        
        # Improved HSV ranges for better accuracy
        red_lower1 = np.array([0, 120, 70])     # More restrictive saturation/value
        red_upper1 = np.array([10, 255, 255])
        red_lower2 = np.array([170, 120, 70])   # Adjusted for better red detection
        red_upper2 = np.array([180, 255, 255])
        
        yellow_lower = np.array([15, 150, 150])  # More restrictive for yellow
        yellow_upper = np.array([35, 255, 255])
        
        green_lower = np.array([40, 120, 70])    # More restrictive for green
        green_upper = np.array([80, 255, 255])
        
        # Create masks
        red_mask1 = cv2.inRange(hsv, red_lower1, red_upper1)
        red_mask2 = cv2.inRange(hsv, red_lower2, red_upper2)
        red_mask = cv2.bitwise_or(red_mask1, red_mask2)
        
        yellow_mask = cv2.inRange(hsv, yellow_lower, yellow_upper)
        green_mask = cv2.inRange(hsv, green_lower, green_upper)
        
        # Count pixels
        red_pixels = cv2.countNonZero(red_mask)
        yellow_pixels = cv2.countNonZero(yellow_mask)
        green_pixels = cv2.countNonZero(green_mask)
        
        # Method 2: BGR color analysis for additional validation
        bgr_red_pixels = self._count_bgr_red_pixels(light_roi)
        
        # Method 3: Brightness analysis (red lights are often brightest)
        gray = cv2.cvtColor(light_roi, cv2.COLOR_BGR2GRAY)
        bright_pixels = cv2.countNonZero(cv2.threshold(gray, 180, 255, cv2.THRESH_BINARY)[1])
        
        # Calculate total pixels for percentage
        total_pixels = light_roi.shape[0] * light_roi.shape[1]
        
        # Improved decision logic
        red_score = red_pixels + (bgr_red_pixels * 0.5)
        yellow_score = yellow_pixels
        green_score = green_pixels
        
        # Minimum threshold - need at least 5% colored pixels
        min_threshold = total_pixels * 0.05
        
        if red_score < min_threshold and yellow_score < min_threshold and green_score < min_threshold:
            return "unknown"
        
        # Red detection with additional validation
        if red_score >= max(yellow_score, green_score):
            # Additional validation for red: check if it's also bright
            if bright_pixels > total_pixels * 0.1:  # At least 10% bright pixels
                return "red"
            elif red_score > min_threshold * 2:  # Strong red signal
                return "red"
        
        # Yellow and green detection
        if yellow_score >= max(red_score, green_score) and yellow_score > min_threshold:
            return "yellow"
        elif green_score >= max(red_score, yellow_score) and green_score > min_threshold:
            return "green"
        
        return "unknown"
    
    def _count_bgr_red_pixels(self, roi: np.ndarray) -> int:
        """Count red pixels using BGR color space for additional validation"""
        # In BGR, red pixels have high B component and low G component
        b, g, r = cv2.split(roi)
        
        # Red condition: R > 100, R > G+30, R > B+30
        red_condition = (r > 100) & (r > g + 30) & (r > b + 30)
        return np.sum(red_condition)
    
    def _check_stop_line_violation(self, detection: DetectionResult, tracker_data: Dict, 
                                 stop_line_zones: Dict) -> bool:
        """Check if vehicle violated stop line - only vehicles crossing the specific zone"""
        if not detection.track_id or detection.track_id not in tracker_data:
            return False
        
        track_positions = tracker_data[detection.track_id]['positions']
        if len(track_positions) < 2:
            return False
        
        # Get vehicle center point
        x1, y1, x2, y2 = detection.bbox
        vehicle_center = ((x1 + x2) // 2, (y1 + y2) // 2)
        vehicle_point = Point(vehicle_center[0], vehicle_center[1])
        
        # Only check vehicles that are currently in or crossing the specific stop line zone
        for zone_id, zone_data in stop_line_zones.items():
            zone_polygon = zone_data['polygon']
            
            # Check if vehicle is currently in the stop line zone
            if zone_polygon.contains(vehicle_point):
                # Check trajectory to see if it entered the zone during red light
                recent_positions = track_positions[-5:]  # Last 5 positions
                
                for i in range(len(recent_positions) - 1):
                    p1 = Point(recent_positions[i][0], recent_positions[i][1])
                    p2 = Point(recent_positions[i+1][0], recent_positions[i+1][1])
                    
                    # If vehicle crossed into the zone (was outside, now inside)
                    if not zone_polygon.contains(p1) and zone_polygon.contains(p2):
                        # Check if it was after red light with grace period
                        if time.time() - self.state_change_time > 1.0:  # Grace period
                            return True
        
        return False



# Removed HelmetSeatbeltViolationDetector, MobilePhoneViolationDetector, and OverloadingDetector as requested

class HeavyVehicleProhibitionDetector(BaseViolationDetector):
    """Detects heavy vehicle entry in prohibited zones"""
    
    def __init__(self):
        super().__init__("Heavy Vehicle Prohibition")
        self.heavy_vehicle_types = ['bus', 'truck']
        
    def detect(self, detections: List[DetectionResult], frame: np.ndarray, 
               tracker_data: Dict, zones: ZoneManager) -> List[ViolationEvent]:
        violations = []
        
        # Get prohibited zones for heavy vehicles
        prohibited_zones = zones.get_zones_by_type("heavy_vehicle_prohibited")
        
        # Only detect violations if prohibited zones are defined
        if not prohibited_zones:
            return violations
        
        for detection in detections:
            if (detection.class_name in self.heavy_vehicle_types and 
                self._check_prohibited_entry(detection, prohibited_zones)):
                
                violation = ViolationEvent(
                    violation_type="heavy_vehicle_prohibition",
                    timestamp=datetime.now(),
                    track_id=detection.track_id,
                    location=(detection.bbox[0], detection.bbox[1]),
                    confidence=0.9,
                    evidence={
                        "bbox": detection.bbox,
                        "vehicle_type": detection.class_name
                    },
                    description=f"{detection.class_name} entered prohibited zone"
                )
                violations.append(violation)
                self.violation_count += 1
                logger.warning(f"Heavy vehicle prohibition violated: Track {detection.track_id}")
        
        return violations
    
    def _check_prohibited_entry(self, detection: DetectionResult, prohibited_zones: Dict) -> bool:
        """Check if heavy vehicle entered prohibited zone"""
        center_x = (detection.bbox[0] + detection.bbox[2]) // 2
        center_y = (detection.bbox[1] + detection.bbox[3]) // 2
        
        for zone_id, zone_data in prohibited_zones.items():
            if zone_data['polygon'].contains(Point(center_x, center_y)):
                return True
        
        return False

class LaneChangeViolationDetector(BaseViolationDetector):
    """Detects illegal lane change violations"""
    
    def __init__(self):
        super().__init__("Lane Change Violation")
        self.processed_crossings = {}  # Track recent crossings to avoid duplicates
        
    def detect(self, detections: List[DetectionResult], frame: np.ndarray, 
               tracker_data: Dict, zones: ZoneManager) -> List[ViolationEvent]:
        violations = []
        
        # Get lane divider lines
        lane_dividers = zones.get_zones_by_type("lane_divider")
        
        # Only detect violations if lane dividers are defined
        if not lane_dividers:
            return violations
        
        current_time = time.time()
        
        # Clean up old processed violations (older than 30 seconds)
        self._cleanup_old_violations(current_time)
        
        # Draw lane divider lines
        self._draw_lane_dividers(frame, lane_dividers)
        
        # Debug: show number of lane dividers
        if lane_dividers:
            cv2.putText(frame, f"Lane Dividers: {len(lane_dividers)}", (10, 30),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
        
        for detection in detections:
            # Check all vehicles
            if detection.class_name in ['car', 'motorcycle', 'bus', 'truck']:
                # Debug: draw bounding box for all vehicles
                x1, y1, x2, y2 = detection.bbox
                cv2.rectangle(frame, (x1, y1), (x2, y2), (255, 0, 255), 1)
                
                if self._check_lane_change_violation(detection, lane_dividers, current_time):
                    violation = ViolationEvent(
                        violation_type="lane_change_violation",
                        timestamp=datetime.now(),
                        track_id=detection.track_id or 0,
                        location=(detection.bbox[0], detection.bbox[1]),
                        confidence=0.85,
                        evidence={
                            "bbox": detection.bbox,
                            "vehicle_type": detection.class_name
                        },
                        description=f"{detection.class_name} crossed lane divider"
                    )
                    violations.append(violation)
                    self.violation_count += 1
                    
                    logger.warning(f"Lane change violation detected: {detection.class_name} crossed lane divider")
                    
                    # Draw violation indicator
                    cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 0, 255), 3)
                    cv2.putText(frame, "LANE VIOLATION", (x1, y1 - 10),
                              cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)
        
        return violations
    
    def _draw_lane_dividers(self, frame: np.ndarray, lane_dividers: Dict):
        """Draw lane divider lines"""
        for zone_id, zone_data in lane_dividers.items():
            points = zone_data['points']
            
            # Draw as a line (lane dividers are always lines)
            if len(points) >= 2:
                line_start = points[0]
                line_end = points[-1]
                
                # Draw thick yellow line for lane divider
                cv2.line(frame, line_start, line_end, (0, 255, 255), 4)  # Yellow line
                
                # Add label
                mid_x = (line_start[0] + line_end[0]) // 2
                mid_y = (line_start[1] + line_end[1]) // 2
                cv2.putText(frame, zone_id, (mid_x, mid_y - 10),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 2)
        

    
    def _check_lane_change_violation(self, detection: DetectionResult, lane_dividers: Dict, current_time: float) -> bool:
        """Check if vehicle bounding box intersects with lane divider line"""
        x1, y1, x2, y2 = detection.bbox
        
        # Check if bounding box intersects any lane divider line
        for zone_id, zone_data in lane_dividers.items():
            line_points = zone_data['points']
            if len(line_points) >= 2:
                line_start = line_points[0]
                line_end = line_points[-1]
                
                # Simple check: does the line pass through the bounding box?
                if self._line_intersects_bbox(line_start, line_end, x1, y1, x2, y2):
                    print(f"INTERSECTION DETECTED: Vehicle bbox ({x1},{y1},{x2},{y2}) intersects {zone_id}")
                    
                    # Create simple key to avoid immediate duplicates
                    bbox_center_x = (x1 + x2) // 2
                    bbox_center_y = (y1 + y2) // 2
                    crossing_key = f"{bbox_center_x//50}_{bbox_center_y//50}_{zone_id}"
                    
                    # Very short cooldown to prevent spam but allow detection
                    if crossing_key in self.processed_crossings:
                        if current_time - self.processed_crossings[crossing_key] < 1.0:
                            print(f"Skipping due to cooldown: {crossing_key}")
                            continue
                    
                    # Mark this crossing
                    self.processed_crossings[crossing_key] = current_time
                    
                    print(f"VIOLATION TRIGGERED: {zone_id}")
                    logger.info(f"Lane change violation: Vehicle intersects {zone_id}")
                    return True
        
        return False
    

    
    def _line_intersects_bbox(self, line_start, line_end, x1, y1, x2, y2):
        """Check if line intersects with bounding box"""
        # Check if line intersects any of the 4 edges of the bounding box
        bbox_edges = [
            (x1, y1, x2, y1),  # top edge
            (x2, y1, x2, y2),  # right edge  
            (x2, y2, x1, y2),  # bottom edge
            (x1, y2, x1, y1)   # left edge
        ]
        
        for edge in bbox_edges:
            if self._lines_intersect(line_start[0], line_start[1], line_end[0], line_end[1],
                                   edge[0], edge[1], edge[2], edge[3]):
                return True
        return False
    
    def _lines_intersect(self, x1, y1, x2, y2, x3, y3, x4, y4):
        """Check if two line segments intersect"""
        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
        if abs(denom) < 1e-10:
            return False
        
        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom
        u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom
        
        return 0 <= t <= 1 and 0 <= u <= 1
    
    def _cleanup_old_violations(self, current_time: float):
        """Remove old records to prevent memory buildup"""
        keys_to_remove = []
        for key, crossing_time in self.processed_crossings.items():
            if current_time - crossing_time > 5.0:
                keys_to_remove.append(key)
        for key in keys_to_remove:
            del self.processed_crossings[key]

class ParkingViolationDetector(BaseViolationDetector):
    """Detects parking violations"""
    
    def __init__(self):
        super().__init__("Parking Violation")
        self.stationary_threshold = 10  # Seconds (reduced from 30 to 10)
        self.stationary_vehicles = {}  # Track by ID
        self.stationary_positions = {}  # Track by position (more stable than IDs)
        
    def detect(self, detections: List[DetectionResult], frame: np.ndarray, 
               tracker_data: Dict, zones: ZoneManager) -> List[ViolationEvent]:
        violations = []
        
        # Get no-parking zones
        no_parking_zones = zones.get_zones_by_type("no_parking")
        
        # Only detect violations if no-parking zones are defined
        if not no_parking_zones:
            return violations
            
        current_time = time.time()
        
        # Draw no-parking zones with more visibility
        for zone_id, zone_data in no_parking_zones.items():
            points = zone_data['points']
            pts = np.array(points, np.int32)
            pts = pts.reshape((-1, 1, 2))
            
            # Create a copy of the frame for the overlay
            overlay = frame.copy()
            
            # Draw a semi-transparent red fill
            cv2.fillPoly(overlay, [pts], (0, 0, 255))  # Red fill
            
            # Blend the overlay with the original frame
            alpha = 0.2  # Transparency factor
            cv2.addWeighted(overlay, alpha, frame, 1 - alpha, 0, frame)
            
            # Draw the outline and label (not transparent)
            cv2.polylines(frame, [pts], True, (0, 0, 255), 2)  # Red outline
            cv2.putText(frame, "NO PARKING ZONE", (points[0][0], points[0][1] - 10),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)
        
        # Draw position-based timers for vehicles being tracked for parking violations
        for position_key, data in self.stationary_positions.items():
            center_x, center_y = data['location']
            current_id = data['current_id']
            
            # Calculate how long the vehicle has been stationary
            stationary_duration = current_time - data['start_time']
            
            # Draw timer at the position
            cv2.putText(frame, f"Parked: {stationary_duration:.1f}s", 
                      (center_x - 50, center_y - 30),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 165, 255), 2)  # Orange
            
            # Draw circle at the position
            cv2.circle(frame, (center_x, center_y), 20, (0, 165, 255), 2)
            
            # Find the detection with the current ID
            for detection in detections:
                if detection.track_id == current_id:
                    x1, y1, x2, y2 = detection.bbox
                    
                    # Draw warning indicator if approaching violation threshold
                    if stationary_duration > self.stationary_threshold * 0.7:  # 70% of threshold
                        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 165, 255), 2)  # Orange
                    break
        
        for detection in detections:
            if detection.class_name in ['car', 'motorcycle', 'bus', 'truck'] and detection.track_id:
                if self._check_parking_violation(detection, tracker_data, no_parking_zones, current_time):
                    # Get position key for this detection
                    x1, y1, x2, y2 = detection.bbox
                    center_x = (x1 + x2) // 2
                    center_y = (y1 + y2) // 2
                    width = x2 - x1
                    height = y2 - y1
                    grid_size = 20
                    position_key = f"{center_x // grid_size}_{center_y // grid_size}_{width // 20}_{height // 20}"
                    
                    # Get the actual start time from position tracking
                    start_time = current_time
                    if position_key in self.stationary_positions:
                        start_time = self.stationary_positions[position_key]['start_time']
                    
                    stationary_duration = current_time - start_time
                    
                    violation = ViolationEvent(
                        violation_type="parking_violation",
                        timestamp=datetime.now(),
                        track_id=detection.track_id,
                        location=(detection.bbox[0], detection.bbox[1]),
                        confidence=0.85,
                        evidence={
                            "bbox": detection.bbox,
                            "vehicle_type": detection.class_name,
                            "stationary_duration": stationary_duration,
                            "position_key": position_key
                        },
                        description=f"{detection.class_name} parked in no-parking zone for {stationary_duration:.1f} seconds"
                    )
                    violations.append(violation)
                    self.violation_count += 1
                    logger.warning(f"Parking violation detected: Position {position_key}, Track {detection.track_id}")
        
        return violations
    
    def _check_parking_violation(self, detection: DetectionResult, tracker_data: Dict, 
                               no_parking_zones: Dict, current_time: float) -> bool:
        """Check for parking violation"""
        if not detection.track_id:
            return False
        
        # Get vehicle center and dimensions
        x1, y1, x2, y2 = detection.bbox
        center_x = (x1 + x2) // 2
        center_y = (y1 + y2) // 2
        width = x2 - x1
        height = y2 - y1
        vehicle_point = Point(center_x, center_y)
        
        # Create a position key for this vehicle (grid cell)
        # This helps track vehicles even if their ID changes
        grid_size = 20  # pixels (reduced for better accuracy)
        position_key = f"{center_x // grid_size}_{center_y // grid_size}_{width // 20}_{height // 20}"
        
        # Check if vehicle is in no-parking zone
        in_no_parking_zone = False
        for zone_id, zone_data in no_parking_zones.items():
            if zone_data['polygon'].contains(vehicle_point):
                in_no_parking_zone = True
                break
        
        if not in_no_parking_zone:
            # Remove from stationary vehicles if not in no-parking zone
            if detection.track_id in self.stationary_vehicles:
                del self.stationary_vehicles[detection.track_id]
            
            # Also check position-based tracking
            if position_key in self.stationary_positions:
                del self.stationary_positions[position_key]
                
            return False
        
        # Check if vehicle is stationary based on tracking data
        is_stationary = True
        if detection.track_id in tracker_data:
            track_positions = tracker_data[detection.track_id]['positions']
            if len(track_positions) >= 5:  # Need at least 5 positions
                # Calculate movement in recent positions
                recent_positions = track_positions[-5:]  # Use last 5 positions
                max_movement = 0
                for i in range(len(recent_positions) - 1):
                    movement = ((recent_positions[i+1][0] - recent_positions[i][0])**2 + 
                              (recent_positions[i+1][1] - recent_positions[i][1])**2)**0.5
                    max_movement = max(max_movement, movement)
                
                # If significant movement detected, not stationary
                if max_movement >= 8:  # 8 pixels threshold
                    is_stationary = False
        
        # Update position-based tracking
        if is_stationary:
            # Start tracking by position if not already tracked
            if position_key not in self.stationary_positions:
                self.stationary_positions[position_key] = {
                    'start_time': current_time,
                    'location': (center_x, center_y),
                    'current_id': detection.track_id
                }
                logger.info(f"Vehicle at position {position_key} started parking in no-parking zone")
            else:
                # Update the current ID for this position
                self.stationary_positions[position_key]['current_id'] = detection.track_id
                
                # Check if stationary for too long
                stationary_duration = current_time - self.stationary_positions[position_key]['start_time']
                logger.info(f"Vehicle at position {position_key} (ID: {detection.track_id}) parked for {stationary_duration:.1f} seconds")
                
                # Also update ID-based tracking for visualization
                self.stationary_vehicles[detection.track_id] = {
                    'start_time': self.stationary_positions[position_key]['start_time'],
                    'location': (center_x, center_y),
                    'position_key': position_key
                }
                
                if stationary_duration > self.stationary_threshold:
                    # Continue generating violations every few seconds for persistent parking
                    # Only generate violation if enough time has passed since last violation
                    last_violation_time = self.stationary_positions[position_key].get('last_violation_time', 0)
                    if current_time - last_violation_time > 5.0:  # Generate violation every 5 seconds
                        self.stationary_positions[position_key]['last_violation_time'] = current_time
                        return True
        else:
            # Vehicle is moving, remove from stationary lists
            if detection.track_id in self.stationary_vehicles:
                position_key = self.stationary_vehicles[detection.track_id].get('position_key')
                if position_key and position_key in self.stationary_positions:
                    del self.stationary_positions[position_key]
                del self.stationary_vehicles[detection.track_id]
                logger.info(f"Vehicle {detection.track_id} moved, no longer considered parked")
        
        return False

class LaneAwareViolationDetector(BaseViolationDetector):
    """Adapter integrating lane_aware_wrong_side with system detections/tracker"""
    def __init__(self):
        super().__init__("Lane-Aware Wrong Side")
        self._lane_detector = LaneAwareWrongSideDetector(output_dir="violations_lane_aware")
        self.enabled = False
        self.setup_done = False
        self.violation_count = 0

    def setup_with_frame(self, frame: np.ndarray):
        """Run interactive lane/direction setup once (blocking)"""
        try:
            self._lane_detector.setup_lanes_and_directions(frame)
            self.setup_done = True
        except Exception as e:
            logger.error(f"Lane-aware setup failed: {e}")

    def detect(self, detections: List[DetectionResult], frame: np.ndarray,
               tracker_data: Dict, zones: ZoneManager) -> List[ViolationEvent]:
        """Convert DetectionResult list into vehicle list expected by lane detector and convert back"""
        if not self.enabled:
            return []

        # If setup not done, skip (or you can trigger setup with current frame)
        if not self.setup_done:
            return []

        # Build vehicles list expected by lane_aware_wrong_side.detect_violations
        vehicles = []
        for d in detections:
            if not getattr(d, "track_id", None):
                continue
            x1, y1, x2, y2 = d.bbox
            center = ((x1 + x2) // 2, (y1 + y2) // 2)
            vehicles.append({
                "id": d.track_id,
                "bbox": d.bbox,
                "center": center,
                "class_name": d.class_name,
                # attach any attributes your lane detector might use
            })

        try:
            raw_violations = self._lane_detector.detect_violations(vehicles, frame.copy(), 
                                                                   tracker_data.get("frame_count", 0))
        except Exception as e:
            logger.error(f"Lane-aware detection error: {e}")
            raw_violations = []

        result_events: List[ViolationEvent] = []
        for rv in (raw_violations or []):
            try:
                vid = rv.get("id", rv.get("vehicle_id", None))
                bbox = rv.get("bbox", (0, 0, 0, 0))
                lane_idx = rv.get("lane", None)
                desc = f"Wrong side driving in lane {lane_idx+1}" if lane_idx is not None else "Wrong side driving"
                ve = ViolationEvent(
                    violation_type="wrong_side_driving",
                    timestamp=datetime.now(),
                    track_id=vid,
                    location=((bbox[0] + bbox[2]) // 2, (bbox[1] + bbox[3]) // 2),
                    confidence=rv.get("confidence", 0.85),
                    evidence={"bbox": bbox, "lane": lane_idx, "motion_vector": rv.get("motion_vector")},
                    description=desc
                )
                result_events.append(ve)
                self.violation_count += 1
            except Exception as e:
                logger.error(f"Error converting lane-aware violation: {e}")

        return result_events

# Violation detector registry
VIOLATION_DETECTORS = {
    'red_light': RedLightViolationDetector(),
    'heavy_vehicle': HeavyVehicleProhibitionDetector(),
    'parking': ParkingViolationDetector(),
    'lane_change': LaneChangeViolationDetector(),
    # lane-aware adapter (disabled by default)
    'lane_aware': LaneAwareViolationDetector()
}

def get_all_violations(detections: List[DetectionResult], frame: np.ndarray, 
                      tracker_data: Dict, zones: ZoneManager) -> List[ViolationEvent]:
    """Get all violations from all enabled detectors"""
    all_violations = []
    
    # Debug: Log detection info
    vehicle_detections = [d for d in detections if d.class_name in ['car', 'motorcycle', 'bus', 'truck']]
    
    for detector_name, detector in VIOLATION_DETECTORS.items():
        if detector.enabled:
            try:
                violations = detector.detect(detections, frame, tracker_data, zones)
                if violations:
                    logger.info(f"{detector_name} detector found {len(violations)} violations")
                all_violations.extend(violations)
            except Exception as e:
                logger.error(f"Error in {detector_name} detector: {e}")
    
    return all_violations

